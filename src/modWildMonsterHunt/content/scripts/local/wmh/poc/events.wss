
////////////////////////////////////////////////////////////////////////////////
// 1.
// @addMethod the event, but also the listeners, manually call the listeners
// from the event

// 1.0
// register the event
@addMethod(WMH_Master)
function submitOnContractCompleted(origin: WMH_ContractManager) {
  // 1.1
  // manually call the listeners
  this.contract.hunt.onContractCompleted();
}

// 1.2
// register a listener
@addMethod(WMH_HuntManager)
function onContractCompleted() {
  // internal logic
}

// NOTES:
// + the 1.2 step can be written alongside the listening class, but also next
//   to the event if wanted.
// + as the listeners are directly added in the classes themselves, they can use
//   `this` and also access private/protected properties.
// + the 1.1 step allows for precise ordering while calling the listeners
// - the 1.1 step can cause human mistakes, e.g. forgetting to add a call there
// - distinction between the function to emit the event, usually prefixed with
//   "submit" and the listeners themselves that don't have the prefix

////////////////////////////////////////////////////////////////////////////////
// 2.
// @addMethod the event, @wrapMethod it for the listeners

// 2.0
// register the event
@addMethod(WMH_Master)
function onContractCompleted(origin: WMH_ContractManager) {
  // 2.1
  // nothing specific to add there, can be left empty
}

// 2.2
// register a listener by wrapping the event
@wrapMethod(WMH_Master)
function onContractCompleted(origin: WMH_ContractManager) {
  wrappedMethod(origin);

  // internal logic,
}

// NOTES:
// + no distinction between the function to emit the event, they all have the
//   same name thanks to the wrapping
// + no human mistake possible as the listeners are automatically triggered by
//   the @wrapMethods
// + the 2.2 step can be written anywhere on the codebase, next to the listening
//   class or next to the 2.0 step
// - as the listeners are wrappers they cannot access the private/protected
//   fields of the class that wants to listen to the event. Ultimately forcing
//   to put everything as public, which in itself isn't that big of a deal if
//   the pub/sub pattern is used for inter-communication but still
// - calls to the listeners is random/undefined, can be problematic if precise
//   order is required which wouldn't be solved by moving `wrappedMethod()` up
//   or down

////////////////////////////////////////////////////////////////////////////////
// 3.
// cahirc extension

// 3.1
@register(events)
class WMH_Master {}

// 3.2
@provider(WMH_getHuntManager)
class WMH_HuntManager {
  @subscribe()
  function onContractCompleted(origin: WMH_ContractManager) {}
}

// would emit:

// 3.1
class WMH_Master {}

// 3.2
function WMH_getHuntManager(): WMH_getHuntManager {
  return thePlayer.wmh.hunt;
}

class WMH_HuntManager {}

@addMethod(WMH_Master)
function onContractCompleted(origin: WMH_ContractManager) {}

@wrapMethod(WMH_Master)
function onContractCompleted(origin: WMH_ContractManager) {
  wrappedMethod(origin);

  WMH_getHuntManager().onContractCompleted(origin);
}