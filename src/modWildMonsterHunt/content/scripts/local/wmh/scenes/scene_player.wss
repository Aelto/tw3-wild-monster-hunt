class WMH_CameraMilestone {
  // seconds after which this milestone will start having an effect on the
  // camera.
  var start_after: float;

  // After `start_after` is completed, blends the movements until the seconds
  // have passed.
  var blendin_seconds: float;

  var target_position: Vector;
  var target_rotation: EulerAngles;

  private var ran_for: float;
  default ran_for = 0.0;

  public function init(
    _start_after: float,
    _blendin_seconds: float,
    _target_position: Vector,
    _target_rotation: EulerAngles
  ): WMH_CameraMilestone {
    this.start_after = _start_after;
    this.blendin_seconds = _blendin_seconds;
    this.target_position = _target_position;
    this.target_rotation = _target_rotation;

    return this;
  }

  public function applyDelta(delta: float): float {
    this.start_after -= delta;

    if (this.start_after > 0.0) {
      return 0.0;
    }

    if (this.ran_for > this.blendin_seconds) {
      return 0.0;
    }

    this.ran_for += delta;

    if (this.blendin_seconds <= 0) {
      return 1.0;
    }

    // bÃ©zier blend:
    // https://stackoverflow.com/questions/13462001/ease-in-and-ease-out-animation-formula
    // var t: float = MinF(this.ran_for / this.blendin_seconds, 1.0);
    // return t * t * (3.0 - 2.0 * t);

    var t: float = MinF(this.ran_for / this.blendin_seconds, 1.0);
    var sqr: float = t*t;
    return sqr / (2.0 * (sqr - t) + 1.0);

    // return PowF(t, 10);
    // return ((1.0 as float) / (this.blendin_seconds as float)) as float;
    // return this.ran_for / this.blendin_seconds;
    // return LogF((this.ran_for / this.blendin_seconds) + 1);
  }

  public function applyPosition(out position: Vector, blendratio: float, delta: float): bool {
    var update_position: bool = 0
      != this.target_position.X
        + this.target_position.Y
        + this.target_position.Z;

    if (!update_position) {
      return false;
    }

    // if (blendratio >= 1) {
    //   delta = 1.0;
    // }

    // if (blendratio >= 1) {
    //   position.X = this.target_position.X;
    //   position.Y = this.target_position.Y;
    //   position.Z = this.target_position.Z;
    // }
    // else {
      position.X += blendratio * delta * (this.target_position.X - position.X);
      position.Y += blendratio * delta * (this.target_position.Y - position.Y);
      position.Z += blendratio * delta * (this.target_position.Z - position.Z);
    // }

    return true;
  }

  public function applyRotation(
    out rotation: EulerAngles,
    blendratio: float,
    delta: float,
    position: Vector
  ): bool {
    var update_rotation: bool = 0
      != this.target_rotation.Roll
       + this.target_rotation.Yaw
       + this.target_rotation.Pitch;

    if (!update_rotation) {
      return false;
    }
      

    // if (blendratio >= 1) {
    //   delta = 1.0;
    // }
    // if (blendratio >= 1) {
    //   rotation.Roll = this.target_rotation.Roll;
    //   rotation.Yaw = this.target_rotation.Yaw;
    //   rotation.Pitch = this.target_rotation.Pitch;
    // }
    // else {
      rotation.Roll += blendratio * delta
        * AngleNormalize180(this.target_rotation.Roll - rotation.Roll);

      rotation.Yaw += blendratio * delta
        * AngleNormalize180(this.target_rotation.Yaw - rotation.Yaw);

      rotation.Pitch += blendratio * delta
        * AngleNormalize180(this.target_rotation.Pitch - rotation.Pitch);
    // }

    return true;
  }
}

class WMH_CameraMilestone_FollowRotation extends WMH_CameraMilestone {
  var followed_entity: CNode;

  public function initFollowRotation(
    start_after: float,
    blendin_seconds: float,
    entity: CNode
  ): WMH_CameraMilestone_FollowRotation {
    this.start_after = start_after;
    this.blendin_seconds = blendin_seconds;
    this.followed_entity = entity;

    return this;
  }

  public function applyRotation(
    out rotation: EulerAngles,
    blendratio: float,
    delta: float,
    position: Vector,
  ): bool {
    this.target_rotation = VecToRotation(
      this.followed_entity.GetWorldPosition() - position
    );

    // because the Pitch (Y axis) is inverted by default
    this.target_rotation.Pitch *= -1;

    return super.applyRotation(rotation, blendratio, delta, position);
  }
}

class WMH_CameraMilestone_Magnet extends WMH_CameraMilestone {
  private var radius: float;
  private var strength: float;

  public function initMagnet(
    start_after: float,
    blendin_seconds: float,
    position: Vector,
    rotation: EulerAngles,
    radius: float,
    strength: float
  ): WMH_CameraMilestone_Magnet {
    this.start_after = start_after;
    this.blendin_seconds = blendin_seconds;
    this.target_position = position;
    this.target_rotation = rotation;
    this.radius = radius;
    this.strength = strength;

    return this;
  }

  private function getPull(position: Vector): float {
    return 1 - ClampF(
      VecDistance(this.target_position, position), 0.0001, this.radius
    ) / this.radius * this.strength;

    // return LogF(MaxF(10 - VecDistance(this.target_position, position), 0) + 2);
  }

  public function applyPosition(
    out position: Vector,
    blendratio: float,
    delta: float
  ): bool {
    super.applyPosition(position, blendratio, delta * this.getPull(position));

    // var diff: Vector = this.target_position - position;

    // position += this.getPull(position) * diff * delta * blendratio;

    return true;
  }

  public function applyRotation(
    out rotation: EulerAngles,
    blendratio: float,
    delta: float,
    position: Vector,
  ): bool {
    super.applyRotation(rotation, blendratio, delta * this.getPull(position), position);

    // var diff: EulerAngles = VecToRotation(this.target_position - position);
    // diff.Pitch *= -1;
    // var pull: float = this.getPull(position) * delta * blendratio * 0.5;

    // rotation.Pitch = AngleNormalize180(rotation.Pitch + diff.Pitch * pull);
    // rotation.Yaw = AngleNormalize180(rotation.Yaw + diff.Yaw * pull);
    // rotation.Roll = AngleNormalize180(rotation.Roll + diff.Roll * pull);

    return true;
  }
}

class WMH_CameraMilestone_Smoother extends WMH_CameraMilestone {
  public function initSmoother(
    start_after: float,
    blendin_seconds: float,
  ): WMH_CameraMilestone_Smoother {
    this.start_after = start_after;
    this.blendin_seconds = blendin_seconds;

    return this;
  }

  private var previous_position: Vector;
  private var position_velocity: Vector;
  public function applyPosition(out position: Vector, blendratio: float, delta: float): bool {
    if (this.previous_position.X+this.previous_position.Y+this.previous_position.X == 0){
      this.previous_position = position;
    }

    var diff: Vector = position - this.previous_position;
    var reducer: float = 1 - delta * 2;

    this.position_velocity = (diff + this.position_velocity) / 2;
    this.position_velocity *= reducer;

    this.previous_position = this.previous_position + this.position_velocity;
    position = this.previous_position;

    return true;
  }

  private var previous_rotation: EulerAngles;
  private var rotation_velocity: EulerAngles;
  public function applyRotation(
    out rotation: EulerAngles,
    blendratio: float,
    delta: float,
    position: Vector,
  ): bool {
    if (this.previous_rotation.Pitch+this.previous_rotation.Yaw+this.previous_rotation.Roll==0) {
      this.previous_rotation = rotation;
    }

    var diff: EulerAngles = EulerAngles(
      rotation.Pitch - this.previous_rotation.Pitch,
      rotation.Yaw - this.previous_rotation.Yaw,
      rotation.Roll - this.previous_rotation.Roll,
    );

    var reducer: float = 1 - delta * 10;

    this.rotation_velocity.Pitch = AngleNormalize180(reducer * this.rotation_velocity.Pitch);
    this.rotation_velocity.Yaw = AngleNormalize180(reducer * this.rotation_velocity.Yaw);
    this.rotation_velocity.Roll = AngleNormalize180(reducer * this.rotation_velocity.Roll);

    this.rotation_velocity.Pitch = AngleNormalize180(diff.Pitch + this.rotation_velocity.Pitch);
    this.rotation_velocity.Yaw = AngleNormalize180(diff.Yaw + this.rotation_velocity.Yaw);
    this.rotation_velocity.Roll = AngleNormalize180(diff.Roll + this.rotation_velocity.Roll);


    this.previous_rotation = EulerAngles(
      AngleNormalize180(this.previous_rotation.Pitch + this.rotation_velocity.Pitch),
      AngleNormalize180(this.previous_rotation.Yaw + this.rotation_velocity.Yaw),
      AngleNormalize180(this.previous_rotation.Roll + this.rotation_velocity.Roll)
    );
    rotation = this.previous_rotation;

    return true;
  }
}

statemachine class WMH_CameraPlayer {
  var milestones: array<WMH_CameraMilestone>;

  public var running: bool;
  public function run() {
    this.running = true;
    WMHINFO("WMH_CameraPlayer.run()");
    this.GotoState('WMH_CameraPlayer_Running');
  }  
}

state WMH_CameraPlayer_Running in WMH_CameraPlayer {
  event OnEnterState(previous_state_name: name) {
    super.OnEnterState(previous_state_name);
    WMHINFO("Running_main");
    this.WMH_CameraPlayer_Running();
  }

  entry function WMH_CameraPlayer_Running() {
    var previous_time: float = theGame.GetEngineTimeAsSeconds();
    var camera: WMH_StaticCamera = WMH_getStaticCamera();

    var position: Vector = thePlayer.GetWorldPosition();
    var rotation: EulerAngles = thePlayer.GetWorldRotation();

    WMHINFO("Running_main");
    camera.TeleportWithRotation(
      position,
      rotation
    );

    camera.activationDuration = 0.25;
    camera.deactivationDuration = 1;
    camera.start();
    SleepOneFrame();

    while (true) {
      var now: float = theGame.GetEngineTimeAsSeconds();
      var delta: float = now - previous_time;
      previous_time = now;

      var has_updated: bool = false;

      // loop through all milestones and apply the currently active ones
      var i: int = 0;
      var max: int = parent.milestones.Size();
      for (i = 0; i < max; i += 1) {
        var blendratio: float = parent.milestones[i].applyDelta(delta);
          LogChannel('WMHINFO', "blendratio = " + blendratio);
        
        if (blendratio > 0) {
          has_updated = true;

          parent.milestones[i].applyPosition(position, blendratio, delta);
          parent.milestones[i].applyRotation(rotation, blendratio, delta, position);
        }
      }

      camera.TeleportWithRotation(position, rotation);
      SleepOneFrame();
    }

    camera.Stop();
  }

  public function tick(
    delta: float,
    camera: WMH_StaticCamera,
    out position: Vector,
    out rotation: EulerAngles
  ): bool {
    
    return true;
  }
}

// enum WMH_CameraTargetType {
//   // when you want the camera to target a node, the node can move
//   WMH_CameraTargetType_NODE = 0,

//   // when you want the camera to target a static position
//   WMH_CameraTargetType_STATIC = 1,

//   // when you want the camera to target a bone component, it can move
//   WMH_CameraTargetType_BONE = 3
// }

// enum WMH_CameraPositionType {
//   // the position will be absolute positions
//   WMH_CameraPositionType_ABSOLUTE = 0,

//   // the position will be relative to the camera's current position.
//   WMH_CameraPositionType_RELATIVE = 1,
// }

// enum WMH_CameraVelocityType {
//   // relative to the rotation of the camera
//   WMH_CameraVelocityType_RELATIVE = 0,

//   WMH_CameraVelocityType_ABSOLUTE = 1,
  
//   WMH_CameraVelocityType_FORWARD = 2,
// }

// struct WMH_CameraScene {
//   // where the camera is placed
//   var position_type: WMH_CameraPositionType;
//   var position: Vector;

//   // where the camera is looking
//   var look_at_target_type: WMH_CameraTargetType;
//   var look_at_target_node: CNode;
//   var look_at_target_static: Vector;
//   var look_at_target_bone: CAnimatedComponent;

//   var duration: float;

//   var velocity_type: WMH_CameraVelocityType;
//   var velocity: Vector;

//   // 1 means no blending at all, while 0 means so much blending it won't move at
//   // all
//   var position_blending_ratio: float;
//   var rotation_blending_ratio: float;

//   // var deactivation_duration: float;
//   // default deactivation_duration = 1.5;

//   // var activation_duration: float;
//   // default activation_duration = 1.5;
// }

// class WMH_StaticCamera extends CStaticCamera {
//   public function setFov(value: float) {
//     var component: CCameraComponent;
//     component = this.GetComponentByClassName('CCameraComponent') as CCameraComponent;

//     // TODO: causes an issue with EE
//     // component.fov = value;
//   }

//   public function start() {
//     this.Run();
//   }

//   public latent function playCameraScenes(scenes: array<WMH_CameraScene>) {
//     var i: int;
//     var current_scene: WMH_CameraScene;

//     for (i = 0; i < scenes.Size(); i += 1) {
//       current_scene = scenes[i];

//       playCameraScene(current_scene);
//     }
//   }

//   private function getRotation(scene: WMH_CameraScene, current_position: Vector): EulerAngles {
//     var current_rotation: EulerAngles;

//     switch (scene.look_at_target_type) {
//       // TODO:
//       // case WMH_CameraTargetType_BONE:
//       //   this.LookAtBone(scene.look_at_target_bone, scene.duration, scene.blend_time);
//       //   break;

//       case WMH_CameraTargetType_STATIC:
//         current_rotation = VecToRotation(scene.look_at_target_static - current_position);
//         break;

//       case WMH_CameraTargetType_NODE:
//         current_rotation = VecToRotation(scene.look_at_target_node.GetWorldPosition() - current_position);
//         break;
//     }

//     // because the Pitch (Y axis) is inverted by default
//     current_rotation.Pitch *= -1;

//     return current_rotation;
//   }

//   public latent function playCameraScene(scene: WMH_CameraScene, optional destroy_after: bool) {
//     var current_rotation: EulerAngles;
//     var current_position: Vector;

//     // immersive camera crashes if there is camera blending when on horse
//     // or in combat.
//     if (theGame.GetInGameConfigWrapper().GetVarValue('RERoptionalFeatures', 'RERcameraScenesDisabledOnHorse')
//     &&  thePlayer.IsUsingHorse() || thePlayer.IsInCombat()) {
//       return;
//     }

//     // this option may cause issues with immersive-camera
//     this.deactivationDuration = 1.5;
//     this.activationDuration = 1.5;

//     this.SetFov(theCamera.GetFov());

//     if (scene.position_type == WMH_CameraPositionType_RELATIVE) {
//       this.TeleportWithRotation(thePlayer.GetWorldPosition() + scene.position, this.getRotation(scene, scene.position));
//     }
//     else {
//       this.TeleportWithRotation(scene.position, this.getRotation(scene, scene.position));
//     }

//     this.Run();
//     Sleep(this.activationDuration);

//     // 1. we always start from the camera's position and its rotation
//     // only if not relative, because relative position starts from (0, 0, 0)
//     // if (scene.position_type != WMH_CameraPositionType_RELATIVE) {
//     current_position = theCamera.GetCameraPosition();
//     // }

//     current_rotation = theCamera.GetCameraRotation();

//     // 2. then we move the camera there and start running
//     this.TeleportWithRotation(current_position, current_rotation);

//     // 3. we start looping to animate the camera toward the scene goals
//     this.blendToScene(scene, current_position, current_rotation);

//     this.Stop();

//     // if (destroy_after) {
//       // removed because it cancels the blending
//       // this.Destroy();
//     // }
//   }

//   private latent function blendToScene(scene: WMH_CameraScene, out current_position: Vector, out current_rotation: EulerAngles) {
//     var goal_rotation: EulerAngles;
//     var starting_time: float;
//     var ending_time: float;
//     var time_progress: float; // it's a %

//     starting_time = theGame.GetEngineTimeAsSeconds();
//     ending_time = starting_time + scene.duration;
//     while (theGame.GetEngineTimeAsSeconds() < ending_time) {
//       time_progress = MinF((theGame.GetEngineTimeAsSeconds() - starting_time) / scene.duration, 0.5);

//       // 1 we do the position & rotation blendings
//       // 1.1 we do the position blending
//       if (scene.position_type == WMH_CameraPositionType_RELATIVE) {
//         current_position += (thePlayer.GetWorldPosition() + scene.position - current_position) * scene.position_blending_ratio * time_progress;
//       }
//       else {
//         current_position += (scene.position - current_position) * scene.position_blending_ratio * time_progress;
//       }

//       // 1.2 we do the rotation blending
//       goal_rotation = this.getRotation(scene, current_position);
//       current_rotation.Roll += AngleNormalize180(goal_rotation.Roll - current_rotation.Roll) * scene.rotation_blending_ratio * time_progress;
//       current_rotation.Yaw += AngleNormalize180(goal_rotation.Yaw - current_rotation.Yaw) * scene.rotation_blending_ratio * time_progress;
//       current_rotation.Pitch += AngleNormalize180(goal_rotation.Pitch - current_rotation.Pitch) * scene.rotation_blending_ratio * time_progress;

//       // 2 we update the goal position using the velocity
//       if (scene.velocity_type == WMH_CameraVelocityType_ABSOLUTE) {
//         scene.position += scene.velocity; // todo: use delta
//       } else if (scene.velocity_type == WMH_CameraVelocityType_FORWARD) {
//         scene.position += VecNormalize(RotForward(current_rotation)) * scene.velocity;
//       }
//       else if (scene.velocity_type == WMH_CameraVelocityType_RELATIVE) {
//         scene.position += VecFromHeading(theCamera.GetCameraHeading()) * scene.velocity;
//       }

//       // 3 we finally teleport the camera
//       this.TeleportWithRotation(current_position, current_rotation);
      
//       SleepOneFrame();
//     }
//   }

// }


// latent function WMH_getStaticCamera(): WMH_StaticCamera {
//   var template: CEntityTemplate;
//   var camera: WMH_StaticCamera;

//   template = LoadResourceAsync("dlc\modtemplates\randomencounterreworkeddlc\data\WMH_static_camera.w2ent", true) as CEntityTemplate;
//   camera = theGame.CreateEntity( template, thePlayer.GetWorldPosition(), thePlayer.GetWorldRotation() ) as WMH_StaticCamera;

//   return camera;
// }