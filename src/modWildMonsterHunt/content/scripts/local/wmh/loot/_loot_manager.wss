@addMethod(WMH_Master)
function submitOnMeldItem() {
  this.loot.onMeldItem(this.storage.herbalist.melding_level.value as int);
  this.storage.herbalist.melding_level.value += 1;
}

statemachine class WMH_LootManager {
  protected var loot_requests: array<WMH_LootRequest>;

  // it uses the value of WMH_LootTag as the first index.
  protected var loot_by_category: array<array<name>>;

  protected var maximum_loot_level: WMH_Level;
  protected var maximum_recipe_level: WMH_Level;

  public function init(): WMH_LootManager {
    this.GotoState('Loading');
    return this;
  }

  public function onContainerRefill(
    inventory: CInventoryComponent,
    out tags: array<WMH_LootTag>,
    seed: int
  ) {

    this.addLootRequest(
      WMH_LootRequest(
        inventory,
        tags,
        seed
      )
    );
  }

  public function onHuntFinished(storage: WMH_Storage) {
    this.maximum_loot_level = storage.general.level;
    this.maximum_recipe_level = storage.herbalist.melding_level;

    // this will cause the loot lists to be refreshed
    this.GotoState('Loading');
  }

  public function onMilestoneContractCompleted(seed: int) {
    var count: int = 4;
    while (count > 0) {
      count -= 1;

      var item: name = this.popRandomItem(WMH_LootTag_Schematic, seed);
      WMHINFO("onMilestoneContractCompleted(), item = " + item);

      if (item == '') {
        break;
      }


      GetWitcherPlayer().AddCraftingSchematic(item);
    }
  }

  public function onMeldItem(seed: int) {
    var item: name = this.popRandomItem(WMH_LootTag_Recipe, seed);
    WMHINFO("onMeldItem(), item = " + item);

    if (item == '') {
      return;
    }

    var entity: CEntity = theGame.GetEntityByTag('WMH_HerbalistContainer');
    var container: WMH_HerbalistContainer = entity as WMH_HerbalistContainer;

    if (container) {
      container.addItem(item);
    }
    else {
      GetWitcherPlayer().AddAlchemyRecipe(item);
    }
  }

  public function getNextMeldItem(optional offset: int): name {
    var max: int = this.loot_by_category[WMH_LootTag_Recipe].Size();

    if (max <= 0) {
      return '';
    }

    var seed: int = thePlayer.wmh.storage.herbalist.melding_level.value as int;
    var item_index: int = RandNoiseF(seed + offset, max) as int;
    var item: name = this.loot_by_category[WMH_LootTag_Recipe][item_index];

    return item;
  }

  private function addLootRequest(request: WMH_LootRequest) {
    this.loot_requests.PushBack(request);

    if (this.GetCurrentStateName() == 'Waiting') {
      this.GotoState('Running');
    }
  }

  protected function registerLoot(category: WMH_LootTag, _level: int, item: name) {
    this.loot_by_category[category].PushBack(item);
  }

  // mutates the array from the category by popping the item out of the list
  // and returning it. Mostly useful for recipes that are given straight to the
  // player
  private function popRandomItem(category: WMH_LootTag, seed: int): name {
    var max: int = this.loot_by_category[category].Size();

    WMHINFO("this.loot_by_category.Size() = " + this.loot_by_category[category].Size());

    if (max <= 0) {
      return '';
    }

    var item_index: int = RandNoiseF(seed, max) as int;
    var item: name = this.loot_by_category[category][item_index];

    this.loot_by_category[category].EraseFast(item_index);

    return item;
  }
}

struct WMH_LootRequest {
  var inventory: CInventoryComponent;
  var tags: array<WMH_LootTag>;
  var seed: int;
}