@addMethod(WMH_Master)
function submitOnMeldItem() {
  this.loot.onMeldItem(this.storage.herbalist.melding_level.value as int);
  this.storage.herbalist.melding_level.value += 1;
}

statemachine class WMH_LootManager {
  protected var loot_requests: array<WMH_LootRequest>;

  // it uses the value of WMH_LootTag as the first index.
  protected var loot_by_category: array<array<name>>;

  protected var runes_of_power_perks: array<ESkill>;
  protected var runes_of_power_perks_roller: WMH_RatiosRoller;

  protected var maximum_loot_level: WMH_Level;
  protected var maximum_recipe_level: WMH_Level;

  public function init(): WMH_LootManager {
    this.GotoState('Loading');
    return this;
  }

  public function onContainerRefill(
    inventory: CInventoryComponent,
    tags: array<WMH_LootTag>, // not `out`, copies the array
    seed: int
  ) {
    var runes_of_power_chance: float = 0.05;

    // the container has no tags: use random tags
    var tags_size: int = tags.Size();
    if (tags_size <= 0) {
      while (tags_size < 3) {  
        if (RandNoiseF(seed + tags_size * 2, tags_size * 1.0) > 0.5) {
          break;
        }

        tags.PushBack(
          RandNoiseF(
            seed + tags_size * 2 + 1,
            (WMH_LootTag_Ore as float) + 1
          ) as int
        );

        tags_size += 1;
      }
    }

    this.addLootRequest(
      WMH_LootRequest(
        inventory,
        tags,
        seed,
        runes_of_power_chance
      )
    );
  }

  public function onHuntFinished(storage: WMH_Storage) {
    this.maximum_loot_level = storage.general.level;
    this.maximum_recipe_level = storage.herbalist.melding_level;

    // this will cause the loot lists to be refreshed
    this.GotoState('Loading');
  }

  public function onMilestoneContractCompleted(seed: int) {
    var count: int = 4;
    while (count > 0) {
      count -= 1;

      var item: name = this.popRandomItem(WMH_LootTag_Schematic, seed);
      WMHINFO("onMilestoneContractCompleted(), item = " + item);

      if (item == '') {
        break;
      }


      GetWitcherPlayer().AddCraftingSchematic(item);
    }
  }

  public function onMeldItem(seed: int) {
    var item: name = this.popRandomItem(WMH_LootTag_Recipe, seed);
    WMHINFO("onMeldItem(), item = " + item);

    // in case the lists are empty
    if (!IsNameValid(item)) {
      item = this.getRandomItem(WMH_LootTag_Alchemy, seed);
    }

    if (!IsNameValid(item)) {
      return;
    }

    var entity: CEntity = theGame.GetEntityByTag('WMH_HerbalistContainer');
    var container: WMH_HerbalistContainer = entity as WMH_HerbalistContainer;

    if (container) {
      container.addItem(item);
    }
  }

  public function getNextMeldItem(optional offset: int): name {
    var max: int = this.loot_by_category[WMH_LootTag_Recipe].Size();

    if (max <= 0) {
      return '';
    }

    var seed: int = thePlayer.wmh.storage.herbalist.melding_level.value as int;
    var item_index: int = RandNoiseF(seed + offset, max) as int;
    var item: name = this.loot_by_category[WMH_LootTag_Recipe][item_index];

    return item;
  }

  public function giveRandomRuneOfPower(
    inventory: CInventoryComponent,
    seed: int,
    optional count: int
  ): array<SItemUniqueId> {
    var runes: array<SItemUniqueId>;

    if (this.runes_of_power_perks.Size() <= 0) {
      return runes;
    }

    runes = inventory
      .AddAnItem('modwmh_rune_of_power', Max(1, count));

    var offset: int = 0;

    for rune: SItemUniqueId in runes {
      var index: int = this.runes_of_power_perks_roller.roll(seed + offset);
      var perk: ESkill = this.runes_of_power_perks[index];

      offset += 1;

      WMH_runeSetPerk(inventory, rune, perk);
    }

    return runes;
  }

  private function addLootRequest(request: WMH_LootRequest) {
    this.loot_requests.PushBack(request);

    if (this.GetCurrentStateName() == 'Waiting') {
      this.GotoState('Running');
    }
  }

  protected function registerLoot(category: WMH_LootTag, _level: int, item: name) {
    this.loot_by_category[category].PushBack(item);
  }

  // mutates the array from the category by popping the item out of the list
  // and returning it. Mostly useful for recipes that are given straight to the
  // player
  protected function popRandomItem(category: WMH_LootTag, seed: int): name {
    var max: int = this.loot_by_category[category].Size();

    if (max <= 0) {
      return '';
    }

    var item_index: int = RandNoiseF(seed, max) as int;
    var item: name = this.loot_by_category[category][item_index];

    this.loot_by_category[category].EraseFast(item_index);

    return item;
  }

  protected function getRandomItem(category: WMH_LootTag, seed: int): name {
    var max: int = this.loot_by_category[category].Size();

    if (max <= 0) {
      return '';
    }

    var item_index: int = RandNoiseF(seed, max) as int;
    var item: name = this.loot_by_category[category][item_index];

    return item;
  }
}

struct WMH_LootRequest {
  var inventory: CInventoryComponent;
  var tags: array<WMH_LootTag>;
  var seed: int;
  var runes_of_power_chance: float;
}