#define const ContractDurationMinutes = 60 * 5;

// Keeps track of the currently active contract targets the player has
class WMH_ContractManager {
  private var pending_contracts: array<WMH_PendingContract>;

  public function init(): WMH_ContractManager {
    todo!("load contracts from storage")

    return this;
  }

  public function onHuntStarted(bestiary: WMH_Bestiary) {
    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onHuntStarted(bestiary);
    }
  }

  public function onHuntFinished(
    bestiary: WMH_Bestiary,
    storage: WMH_Storage,
    killed_creatures: array<WMH_BestiaryId>
  ) {
    // side-effect: the storage is mutated from this
    this.finishCompletedContracts(
      killed_creatures,
      storage,
    );

    var new_level: WMH_Level = storage.general.level;

    this.finishExpiredContracts(new_level);

    var contracts_to_generate: int = 5 - this.pending_contracts.Size();

    if (contracts_to_generate > 0) {
      this.generateNewPendingContracts(
        bestiary,
        new_level,
        contracts_to_generate
      );
    }
  }

  public function onSpawn(bestiary: WMH_Bestiary, seed: int) {
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onSpawn(bestiary, seed);
    }

    // the order in the function calls is important, we want the spawnpoints to
    // be used for spawning creatures first then the ones that were skipped will
    // have a chance to spawn clues.
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onSpawn_clues(bestiary, seed);
    }
  }

  public function isTargetted(id: WMH_BestiaryId): bool {
    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.isTargetted(id)) {
        return true;
      }
    }

    return false;
  }

  public function getPendingTargetsNameHtml(): array<string> {
    var output: array<string>;

    for pending: WMH_PendingContract in this.pending_contracts {
      output.PushBack(pending.toTargetLocNameHtml());
    }

    return output;
  }

  private function onContractCompleted(
    pending: WMH_PendingContract,
    storage: WMH_Storage
  ) {
    WMHHUD("Contract completed.");

    // the formula makes that any contract of the same level grants 100% of a
    // level as experience. Then as the general.level increases it will require
    // stronger and stronger contracts to level up.
    storage.general.level.value += MinF(
      (pending.contract.level.value + 1)
      / (storage.general.level.value + 1),

      // the maximum of levels that we can get from a single contract:
      2
    );
    pending.onContractCompleted();

  }

  private function finishCompletedContracts(
    killed_creatures: array<WMH_BestiaryId>,
    storage: WMH_Storage
  ) {
    var completed_contracts: array<WMH_PendingContract>;

    var id: WMH_BestiaryId;
    for id: WMH_BestiaryId in killed_creatures {
      var contract: WMH_PendingContract;
      
      for contract: WMH_PendingContract in this.pending_contracts {
        if (contract.isTargetted(id)) {
          completed_contracts.PushBack(contract);
        }
      }
    }

    for contract: WMH_PendingContract in completed_contracts {
      this.pending_contracts.Remove(contract);
      this.onContractCompleted(contract, storage);
    }
  }

  private function finishExpiredContracts(level: WMH_Level) {
    var expired_contracts: array<WMH_PendingContract>;

    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.isContractExpired()) {
        expired_contracts.PushBack(contract);
      }
    }

    for contract: WMH_PendingContract in expired_contracts {
      this.pending_contracts.Remove(contract);
    }
  }

  private function generateNewPendingContracts(
    bestiary: WMH_Bestiary,
    level: WMH_Level,
    count: int
  ) {
    var now: int = WMH_getGameTimeMinutes();
    var elites: array<WMH_BestiaryEntry> = bestiary.getEliteEntries(level);
    
    var i: int;
    for (i = count; i > 0; i -= 1) {
      var seed: int = now + i;

      var target_index: int = RandNoiseF(seed, elites.Size() as float) as int;
      var bentry: WMH_BestiaryEntry = elites[target_index];

      var contract: WMH_Contract = WMH_Contract(
        bentry,
        // set a level to the contract with a small variance
        WMH_Level(MaxF(
          level.value + (RandNoiseF(seed, 2.0) - 1.0),
          0
        )),
        now,
        i
      );

      this.pending_contracts.PushBack(
        (new WMH_PendingContract in this).init(contract)
      );
    }
  }
}