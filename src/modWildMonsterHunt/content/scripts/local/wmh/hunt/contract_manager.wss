#define const ContractDurationMinutes = 60 * 5;

// Keeps track of the currently active contract targets the player has
class WMH_ContractManager {
  private var pending_contracts: array<WMH_PendingContract>;

  public function init(bestiary: WMH_Bestiary, storage: WMH_Storage): WMH_ContractManager {
    this.onHuntFinished(bestiary, storage);

    return this;
  }

  public function onHuntStarted(bestiary: WMH_Bestiary) {
    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onHuntStarted(bestiary);
    }
  }

  public function onHuntFinished(
    bestiary: WMH_Bestiary,
    storage: WMH_Storage,
    optional killed_creatures: array<WMH_BestiaryId>
  ) {
    var previous_level: WMH_Level = storage.general.level;
    var next_milestone: WMH_Level = WMH_Level(
      ((previous_level.value as int) / this.milestoneContractsInterval() + 1)
      * this.milestoneContractsInterval()
    );

    // side-effect: the storage is mutated from this
    this.finishCompletedContracts(
      killed_creatures,
      storage,
      next_milestone
    );

    var new_level: WMH_Level = storage.general.level;

    this.finishExpiredContracts(new_level);

    var milestones_to_generate: int = (new_level.value >= next_milestone.value) as int;

    var contracts_to_generate: int = 5
                                   - this.pending_contracts.Size()
                                   - milestones_to_generate;

    if (milestones_to_generate > 0) {
      this.generateNewPendingContracts(
        bestiary,
        storage.contract,
        storage.contract.milestone_level,
        1, // only generate one milestone at a time
        WMH_PendingContractType_MILESTONE
      );
    }

    if (contracts_to_generate > 0) {
      this.generateNewPendingContracts(
        bestiary,
        storage.contract,
        new_level,
        contracts_to_generate,
        WMH_PendingContractType_DEFAULT
      );
    }

    this.loadContractsFromStorage(bestiary, storage.contract);
  }

  public function onSpawn(bestiary: WMH_Bestiary, seed: int) {
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onSpawn(bestiary, seed);
    }

    // the order in the function calls is important, we want the spawnpoints to
    // be used for spawning creatures first then the ones that were skipped will
    // have a chance to spawn clues.
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onSpawn_clues(bestiary, seed);
    }
  }

  public function isTargetted(id: WMH_BestiaryId): bool {
    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.isTargetted(id)) {
        return true;
      }
    }

    return false;
  }

  public function getPendingTargetsNameHtml(): array<string> {
    var output: array<string>;

    for pending: WMH_PendingContract in this.pending_contracts {
      output.PushBack(pending.toTargetLocNameHtml());
    }

    return output;
  }

  private function onContractCompleted(
    pending: WMH_PendingContract,
    storage: WMH_Storage,
    maximum_level: WMH_Level
  ) {
    WMHHUD("Contract completed.");

    pending.onContractCompleted();

    // experience gain is locked until the milestone contract is completed.
    if (!this.hasPendingMilestoneContract()) {
      storage.general.level.value = MinF(
        maximum_level.value,

        // the formula makes that any contract of the same level grants 100% of a
        // level as experience. Then as the general.level increases it will require
        // stronger and stronger contracts to level up.
        storage.general.level.value + MinF(
          (pending.contract.level.value + 1)
          / (storage.general.level.value + 1),

          // the maximum of levels that we can get from a single contract:
          2
        )
      );
    }
  }

  private function finishCompletedContracts(
    killed_creatures: array<WMH_BestiaryId>,
    storage: WMH_Storage,
    maximum_level: WMH_Level
  ) {
    var completed_contracts: array<WMH_PendingContract>;

    // 1.0
    // first complete the milestone contracts to unlock the XP
    for contract: WMH_PendingContract in this.pending_contracts {
      var milestone: WMH_MilestoneContract = contract as WMH_MilestoneContract;

      if (milestone) {
        for id: WMH_BestiaryId in killed_creatures {
          if (milestone.isTargetted(id)) {
            completed_contracts.PushBack(milestone);
          }
        }
      }
    }

    for contract: WMH_PendingContract in completed_contracts {
      this.pending_contracts.Remove(contract);
      this.onContractCompleted(contract, storage, maximum_level);
    }

    // 2.0
    // then complete the regular pending contracts
    for id: WMH_BestiaryId in killed_creatures {
      var contract: WMH_PendingContract;
      
      for contract: WMH_PendingContract in this.pending_contracts {
        if (contract.isTargetted(id)) {
          completed_contracts.PushBack(contract);
        }
      }
    }

    for contract: WMH_PendingContract in completed_contracts {
      this.pending_contracts.Remove(contract);
      this.onContractCompleted(contract, storage, maximum_level);
    }
  }

  private function hasPendingMilestoneContract(): bool {
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.getType() == WMH_PendingContractType_MILESTONE) {
        return true;
      }
    }

    return false;
  }

  private function finishExpiredContracts(level: WMH_Level) {
    var expired_contracts: array<WMH_PendingContract>;

    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.isContractExpired()) {
        expired_contracts.PushBack(contract);
      }
    }

    for contract: WMH_PendingContract in expired_contracts {
      this.pending_contracts.Remove(contract);
    }
  }

  private function generateNewPendingContracts(
    bestiary: WMH_Bestiary,
    storage_contract: WMH_StorageContract,
    level: WMH_Level,
    count: int,
    contract_type: WMH_PendingContractType
  ) {
    var now: int = WMH_getGameTimeMinutes();
    
    var i: int;
    for (i = count; i > 0; i -= 1) {
      storage_contract.pending_contracts.PushBack(
        WMH_Contract(
          level,
          now,
          i,
          contract_type
        )
      );
    }
  }

  private function loadContractsFromStorage(
    bestiary: WMH_Bestiary,
    storage_contract: WMH_StorageContract
  ) {
    this.pending_contracts.Clear();

    for contract: WMH_Contract in storage_contract.pending_contracts {
      if (contract.type == WMH_PendingContractType_MILESTONE) {
        this.pending_contracts.PushBack(
          (new WMH_MilestoneContract in this)
            .initMilestoneContract(bestiary, contract)
        );
      }
      else {
        this.pending_contracts.PushBack(
          (new WMH_PendingContract in this)
            .init(bestiary, contract)
        );
      }
    }
  }

  // returns how many WMH_Levels are needed before a new milestone contract is
  // generated.
  private function milestoneContractsInterval(): int {
    return 5;
  }
}