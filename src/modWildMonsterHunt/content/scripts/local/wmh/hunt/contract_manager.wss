#define const ContractDurationMinutes = 60 * 5;

struct WMH_Contract {
  var target: WMH_BestiaryEntry;

  var created_at_minutes: int;

  // to differentiate otherwise similar contracts that were generated in the
  // same time span.
  var index: int;
}

// Keeps track of the currently active contract targets the player has
class WMH_ContractManager {
  private var pending_contracts: array<WMH_PendingContract>;

  public function init(): WMH_ContractManager {
    todo!("load contracts from storage")

    return this;
  }

  public function onHuntStarted(bestiary: WMH_Bestiary) {
    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onHuntStarted(bestiary);
    }
  }

  public function onHuntFinished(
    bestiary: WMH_Bestiary,
    storage: WMH_Storage,
    killed_creatures: array<WMH_BestiaryId>
  ) {
    var new_level: WMH_Level = this.finishCompletedContracts(
      killed_creatures,
      storage.general.level,
    );

    this.finishExpiredContracts(new_level);

    var contracts_to_generate: int = 5 - this.pending_contracts.Size();

    if (contracts_to_generate > 0) {
      this.generateNewPendingContracts(
        bestiary,
        new_level,
        contracts_to_generate
      );
    }

    storage.general.level = new_level;
  }

  public function onSpawn(bestiary: WMH_Bestiary, seed: int) {
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onSpawn(bestiary, seed);
    }

    // the order in the function calls is important, we want the spawnpoints to
    // be used for spawning creatures first then the ones that were skipped will
    // have a chance to spawn clues.
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onSpawn_clues(bestiary, seed);
    }
  }

  public function isTargetted(id: WMH_BestiaryId): bool {
    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.isTargetted(id)) {
        return true;
      }
    }

    return false;
  }

  private function onContractCompleted(contract: WMH_PendingContract) {
    WMHHUD("Contract completed.");

    todo!("grant rewards")
  }

  private function finishCompletedContracts(
    killed_creatures: array<WMH_BestiaryId>,
    level: WMH_Level
  ): WMH_Level {
    var completed_contracts: array<WMH_PendingContract>;

    var id: WMH_BestiaryId;
    for id: WMH_BestiaryId in killed_creatures {
      var contract: WMH_PendingContract;
      
      for contract: WMH_PendingContract in this.pending_contracts {
        if (contract.isTargetted(id)) {
          completed_contracts.PushBack(contract);
        }
      }
    }

    for contract: WMH_PendingContract in completed_contracts {
      this.pending_contracts.Remove(contract);
      this.onContractCompleted(contract);
    }

    return WMH_Level(level.value + completed_contracts.Size());
  }

  private function finishExpiredContracts(level: WMH_Level) {
    var expired_contracts: array<WMH_PendingContract>;

    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.isContractExpired()) {
        expired_contracts.PushBack(contract);
      }
    }

    for contract: WMH_PendingContract in expired_contracts {
      this.pending_contracts.Remove(contract);
    }
  }

  private function generateNewPendingContracts(
    bestiary: WMH_Bestiary,
    level: WMH_Level,
    count: int
  ) {
    var now: int = WMH_getGameTimeMinutes();
    var elites: array<WMH_BestiaryEntry> = bestiary.getEliteEntries(level);
    
    var i: int;
    for (i = count; i > 0; i -= 1) {
      var seed: int = now + i;

      var target_index: int = RandNoiseF(seed, elites.Size() as float) as int;
      var bentry: WMH_BestiaryEntry = elites[target_index];

      var contract: WMH_Contract = WMH_Contract(
        bentry,
        now,
        i
      );

      this.pending_contracts.PushBack(
        (new WMH_PendingContract in this).init(contract)
      );
    }
  }
}