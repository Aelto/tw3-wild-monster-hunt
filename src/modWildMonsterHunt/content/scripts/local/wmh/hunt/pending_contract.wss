struct WMH_PendingContractLocation {
  var spawn_point: WMH_BiomeSpawnPoint;

  // Dynamic, you may leave it empty as it will be defined during gameplay.
  //
  // Defines the available locations for the contract based on all the spawn
  // points available in the level.
  var general_heading: float;

  // Dynamic, stores the location of the previous clues to be used to determine
  // the position of the next clue (as long as it follow the general_heading).
  //
  // matches the index of `available_locations`
  var previous_clue_location: Vector;
}

struct WMH_Contract {
  var level: WMH_Level;

  var created_at_minutes: int;

  // to differentiate otherwise similar contracts that were generated in the
  // same time span.
  var index: int;

  var type: WMH_PendingContractType;
}

enum WMH_PendingContractType {
  WMH_PendingContractType_DEFAULT = 0,
  WMH_PendingContractType_MILESTONE = 1,
}

class WMH_PendingContract {
  var contract: WMH_Contract;
  var affix_manager: WMH_AffixManager;

  // Dynamic, you may leave it empty as it will be defined during gameplay.
  //
  // Defines the available locations for the contract based on all the spawn
  // points available in the level.
  var available_locations: array<WMH_PendingContractLocation>;

  var was_spawned: bool;

  var target: WMH_BestiaryEntry;

  public function init(bestiary: WMH_Bestiary, contract: WMH_Contract): WMH_PendingContract {
    this.contract = contract;

    this.target = bestiary.getRandomUnfilteredEliteEntry(
      contract.level,
      this.getContractSeed()
    );

    this.affix_manager = (new WMH_AffixManager in this)
      .init(this.contract.level, this.getContractSeed(1));

    WMHHUD("New contract: " + this.toTargetLocNameHtml());

    return this;
  }

  public function onHuntStarted(bestiary: WMH_Bestiary) {
    var spawn_points: array<WMH_BiomeSpawnPoint> = bestiary
      .getAvailableRegionSpawnPoints(this.target);

    var player_position: Vector = thePlayer.GetWorldPosition();
    
    for point: WMH_BiomeSpawnPoint in spawn_points {
      this.available_locations.PushBack(
        WMH_PendingContractLocation(
          point,
          VecHeading(point.GetWorldPosition() - player_position),
          // at the start there is no previous clue so we set it to the player's
          // position
          player_position
        )
      );
    }


    this.was_spawned = false;
  }

  public function onSpawn(bestiary: WMH_Bestiary, hunt_seed: int) {
    this.trySpawningTarget(hunt_seed);
  }

  public function onSpawn_clues(bestiary: WMH_Bestiary, hunt_seed: int) {
    this.trySpawningClues(bestiary, hunt_seed);
  }

  public function isContractExpired(): bool {
    var now: int = WMH_getGameTimeMinutes();

    return now - this.contract.created_at_minutes >= ContractDurationMinutes!;
  }

  public function isTargetted(id: WMH_BestiaryId): bool {
    return this.target.id.value == id.value;
  }

  public function getContractSeed(optional offset: int): int {
    return offset
         + (this.contract.level.value as int)
         - this.contract.created_at_minutes
         + this.contract.index;
  }

  public function toTargetLocNameHtml(): string {
    // note: the affixes are prefixed by a space
    return this.affix_manager.toLocString()
         + this.target.getLocName();
  }

  public function getType(): WMH_PendingContractType {
    return WMH_PendingContractType_DEFAULT;
  }

  public function onContractCompleted() {
    thePlayer.AddMoney(
      (
        this.target.strength
        // at level 25 the rewards are doubled
        * (1 + this.contract.level.value / 25)
      ) as int
    );
  }

  private function getTargetLocationIndex(hunt_seed: int): int {
    var seed: int = this.getContractSeed(hunt_seed);

    // the target spawns on 1 pre-determined location for the contract.
    var index: int = RandNoiseF(
      seed,
      this.available_locations.Size()
    ) as int;

    return index;
  }

  private function trySpawningTarget(hunt_seed: int) {
    if (this.was_spawned) {
      return;
    }

    var index: int = this.getTargetLocationIndex(hunt_seed);
    var location: WMH_PendingContractLocation = this.available_locations[index];

    if (location.spawn_point) {
      var max_distance: float = 150 * 150;
      var distance: float = VecDistanceSquared2D(
        thePlayer.GetWorldPosition(),
        location.spawn_point.GetWorldPosition()
      );

      if (distance <= max_distance) {
        thePlayer.wmh.submitOnSpawnContractTarget(
          this,
          this.target,
          location.spawn_point,
          hunt_seed
        );

        // note that we do not check for its validity before, we don't want
        // regular spawns to postpone the appearance of the target.
        location.spawn_point.consume();
        this.was_spawned = true;
      }
    }
  }

  private function trySpawningClues(bestiary: WMH_Bestiary, hunt_seed: int) {
    if (this.was_spawned) {
      return;
    }

    var clues_points: array<WMH_BiomeSpawnPoint>;
    var spawn_points: array<WMH_BiomeSpawnPoint> = bestiary
      .getAvailableNearbySpawnPoints(this.target);

      // WMHINFO("trySpawningClues(), points.Size() = " + spawn_points.Size());

    var target_index: int = this.getTargetLocationIndex(hunt_seed);
    var target_location_copy: WMH_PendingContractLocation = this
      .available_locations[target_index];

    for point: WMH_BiomeSpawnPoint in spawn_points {
      if (!point.is_clues_location) {
        continue;
      }

      var position: Vector = point.GetWorldPosition();
      // WMHINFO("BiomeCluesPoint @ " + VecToString(position));

      // this point is the target, no need to spawn clues there
      if (position == target_location_copy.spawn_point.GetWorldPosition()) {
        continue;
      }

      // the +10 is a simple offset to ensure this seed isn't use in other
      // calculations using this point_seed.
      var point_seed: int = (hunt_seed + position.X - position.Y + 10) as int;

      // not all valid locations are used everytime,
      if (RandNoiseF(point_seed, 1.0) < 0.5) {
        continue;
      }

      // WMHINFO("BiomeCluesPoint - RandNoiseF success");

      var point_to_target_heading: float = VecHeading(
        target_location_copy.spawn_point.GetWorldPosition() - position
      );

      var previous_to_point_heading: float = VecHeading(
        position - target_location_copy.previous_clue_location
      );

      // As we get closer to the target, the maximum angle increases to allow
      // for more locations.
      // Note that it is both 120deg left and right so a total of 240deg
      var maximum_angle: float = MaxF(
        120
        // every 50m away from the target decreases the cone by 1deg 
        - (
          VecDistance(position, target_location_copy.previous_clue_location)
          / 50
        ),
        20
      );

      // note that it is the angle from the current point to the target, and not
      // from the previous to the current point.
      var heading_difference: float = AngleDistance(
        target_location_copy.general_heading,
        point_to_target_heading
      );

      if (AbsF(heading_difference) > maximum_angle) {
        continue;
      }

      // WMHINFO("BiomeCluesPoint - heading_difference success");

      thePlayer.wmh.submitOnSpawnClues(
        this,
        this.target,
        point,
        // the heading to the target destination
        point_to_target_heading,
        point_seed,
      );

      // update position of the previous clue:
      this.available_locations[target_index].previous_clue_location = position;
      point.consume();
    }
  }
}