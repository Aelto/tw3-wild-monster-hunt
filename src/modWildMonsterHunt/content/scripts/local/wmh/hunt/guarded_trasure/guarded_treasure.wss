statemachine class WMH_GuardedTreasure extends WMH_DynDecoration {
  protected var origin: WMH_BiomeSpawnPoint;
  protected var seed: int;

  public var hostile_entities: array<CEntity>;

  protected editable var creature_bypass_tags: array<name>;
  hint creature_bypass_tags = "If let empty, will default to using the biome data. If filled then the treasure shall only host creatures with the supplied tags.";

  protected editable var spawn_rate_decrease: float;
  default spawn_rate_decrease = 1.0;
  hint spawn_rate_decrease = "How much the chances of spawning a new creature is decreased after every spawn. It should be a value in the ]0;1] range, for example if 0.3 then after spawning 1 creature the chances of spawning a second creature will be lowered to 0.7.";

  event OnSpawned(spawnData: SEntitySpawnData) {
    super.OnSpawned(spawnData);
    this.seed = this.getSeed(WMH_getHuntManager().getSeed());
	}

  public function init(origin: WMH_BiomeSpawnPoint) {
    this.origin = origin;
    this.spawnEntities();
  }

  public function getSeed(optional offset: int): int {
    var position: Vector = this.GetWorldPosition();

    return (position.X as int) - (position.Y as int);
  }

  //#region spawning of entities
  // OVERRIDE to return a custom bestiary entry if needed 
  // 
  // as long as the returned bool is true it will continue to increase the index
  // in order to get new bestiary entries to spawn
  private function getBestiaryEntryToSpawn(
    index: int,
    bestiary: WMH_Bestiary,
    contract: WMH_ContractManager,
    out bentry: WMH_BestiaryEntry
  ): bool {
    // as creatures are spawned, the chances of spawning new groups is
    // progressively lowered.
    if (index > 0) {
      var current_chances: float = 1.0 - this.spawn_rate_decrease * index;

      if (RandNoiseF(this.seed + 30 + index, 1.0) > current_chances) {
        return false;
      }
    }

    var tags_count: int = this.creature_bypass_tags.Size();
    // perform a search by tag
    if (tags_count > 0) {
      var tag_index: int = RandNoiseF(this.seed + 40 + index, tags_count);

      bentry = bestiary
        .getEntryByBiomeTagByPass(this.creature_bypass_tags[tag_index]);
    }
    // perform a fully PRNG search
    else {
      var options: WMH_getRandomEntryOptions;
      options.exclude_strong_target = !this.origin.allow_strong_targets;
      options.exclude_weak_target = !this.origin.allow_weak_targets;

      bentry = bestiary.active_view.getRandomEntry(
        contract,
        bestiary.biomes,
        this.origin.biome_tags,
        this.origin.biome_tags_bypass,
        this.seed + 1,
        options
      );
    }

    return true;
  }

  private function spawnEntities() {
    var spawn_slots: array<CComponent>;
    this.getSpawnSlots(spawn_slots);

    var bestiary: WMH_Bestiary = WMH_getBestiary();
    var contract: WMH_ContractManager = WMH_getContractManager();

    var i: int = 0;

    // 10, a soft limit in case something goes wrong and it never stops spawning
    while (i < 10) {
      var bentry: WMH_BestiaryEntry;
      var should_spawn: bool = this.getBestiaryEntryToSpawn(
        i,
        bestiary,
        contract,
        bentry
      );

      if (!should_spawn) {
        break;
      }

      var spawn_position: Vector;
      var slots_count: int = spawn_slots.Size();
      if (slots_count > 0) {
        var slot_index: int = RandNoiseF(
          this.seed + 10 + i,
          slots_count
        ) as int;

        var slot: CComponent = spawn_slots[slot_index];
        spawn_position = slot.GetWorldPosition();
      }
      else {
        spawn_position = this.origin.GetWorldPosition();
      }

      bestiary.onSpawnGuardedTreasure(
        this,
        bentry,
        spawn_position,
        this.seed + 20 + i
      );

      i += 1;
    }
  }

  private function getSpawnSlots(out slots: array<CComponent>) {
    slots = this
      .GetComponentsByClassName('WMH_GuardedTreasure_SpawnComponent');
  }
  //#endregion
}