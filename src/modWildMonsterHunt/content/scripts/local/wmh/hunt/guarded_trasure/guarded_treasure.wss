exec function wmhgennearbytreasures() {
  WMH_generateNearbyTreasures(50);
}

function WMH_generateNearbyTreasures(radius: float) {
  var entities: array<CGameplayEntity>;

  FindGameplayEntitiesInRange(
    entities,
    thePlayer,
    radius,
    100,
    , //tags
    , // queryflags
    , // target
    'WMH_GuardedTreasure'
  );

  for entity: CGameplayEntity in entities {
    var treasure: WMH_GuardedTreasure = entity as WMH_GuardedTreasure;

    if (!treasure) {
      continue;
    }

    treasure.requestAsynchronousGeneration();
  }
}

statemachine class WMH_GuardedTreasure extends WMH_DynDecoration {
  public var origin: WMH_BiomeSpawnPoint;

  protected var encounters: array<WMH_EncounterGuardedTreasure>;
  // stores whether the encounter at the given index was already spawned and
  // killed.
  protected var encounters_killed: array<bool>;

  protected editable var creature_bypass_tags: array<name>;
  hint creature_bypass_tags = "If let empty, will default to using the biome data. If filled then the treasure shall only host creatures with the supplied tags.";

  protected editable var spawn_rate_decrease: float;
  default spawn_rate_decrease = 1.0;
  hint spawn_rate_decrease = "How much the chances of spawning a new creature is decreased after every spawn. It should be a value in the ]0;1] range, for example if 0.3 then after spawning 1 creature the chances of spawning a second creature will be lowered to 0.7.";

  event OnSpawned(spawnData: SEntitySpawnData) {
    super.OnSpawned(spawnData);
	}

  public function init(origin: WMH_BiomeSpawnPoint) {
    this.origin = origin;
    this.spawnEntities();
  }

  //#region spawning of entities
  // OVERRIDE to return a custom bestiary entry if needed 
  // 
  // as long as the returned bool is true it will continue to increase the index
  // in order to get new bestiary entries to spawn
  private function getBestiaryEntryToSpawn(
    index: int,
    bestiary: WMH_Bestiary,
    contract: WMH_ContractManager,
    out bentry: WMH_BestiaryEntry
  ): bool {
    // as creatures are spawned, the chances of spawning new groups is
    // progressively lowered.
    if (index > 0) {
      var current_chances: float = 1.0 - this.spawn_rate_decrease * index;

      if (RandNoiseF(this.getSeed(30 + index), 1.0) > current_chances) {
        return false;
      }
    }

    var tags_count: int = this.creature_bypass_tags.Size();
    // perform a search by tag
    if (tags_count > 0) {
      var tag_index: int = RandNoiseF(
        this.getSeed(40 + index),
        tags_count
      ) as int;

      bentry = bestiary
        .getEntryByBiomeTagByPass(this.creature_bypass_tags[tag_index]);
    }
    // perform a fully PRNG search
    else {
      var options: WMH_getRandomEntryOptions;
      options.exclude_strong_target = !this.origin.allow_strong_targets;
      options.exclude_weak_target = !this.origin.allow_weak_targets;

      bentry = bestiary.active_view.getRandomEntry(
        contract,
        bestiary.biomes,
        this.origin.biome_tags,
        this.origin.biome_tags_bypass,
        this.getSeed(1),
        options
      );
    }

    return true;
  }

  private function spawnEntities() {
    var spawn_slots: array<CComponent>;
    this.getSpawnSlots(spawn_slots);

    var bestiary: WMH_Bestiary = WMH_getBestiary();
    var contract: WMH_ContractManager = WMH_getContractManager();

    var i: int = 0;

    // 10, a soft limit in case something goes wrong and it never stops spawning
    while (i < 10) {
      if (this.encounters_killed.Size() > index) {
        // the encounter was already spawned and killed in the past,
        // the check is done outside of the getBestiaryEntryToSpawn's index
        // check as this can prevent this encounter from spawning but doesn't
        // break the loop entirely.
        if (this.encounters_killed[index]) {
          continue;
        }
      }

      var bentry: WMH_BestiaryEntry;
      var should_spawn: bool = this.getBestiaryEntryToSpawn(
        i,
        bestiary,
        contract,
        bentry
      );

      if (!should_spawn) {
        break;
      }

      var spawn_position: Vector;
      var slots_count: int = spawn_slots.Size();
      if (slots_count > 0) {
        var slot_index: int = RandNoiseF(
          this.getSeed(10 + i),
          slots_count
        ) as int;

        var slot: CComponent = spawn_slots[slot_index];
        spawn_position = slot.GetWorldPosition();
      }
      else {
        spawn_position = this.origin.GetWorldPosition();
      }

      bestiary.onSpawnGuardedTreasure(
        this,
        bentry,
        spawn_position,
        this.getSeed(20 + i)
      );

      i += 1;
    }
  }

  private function getSpawnSlots(out slots: array<CComponent>) {
    slots = this
      .GetComponentsByClassName('WMH_GuardedTreasure_SpawnComponent');
  }

  public function onEncounterSpawned(
    encounter: WMH_EncounterGuardedTreasure
  ) {
    this.encounters.PushBack(encounter);
    this.encounters_killed.PushBack(false);

    encounter.treasure_index = this.encounters.Size() - 1;

    WMH_getEncounterManager().onGuardedTreasureSpawned(encounter);
  }

  public function onEncounterDestroyed(
    encounter: WMH_EncounterGuardedTreasure
  ) {
    if (this.encounters_killed.Size() > encounter.treasure_index) {
      this
        .encounters_killed[encounter.treasure_index] = encounter.isCompleted();
    }

    this.encounters.Remove(encounter);
  }
  //#endregion
}