#define const HuntSeedOffset_difficulty = 10;

// Stores the data about the currently active hunt
statemachine class WMH_HuntManager {
  private var master: WMH_Master;

  protected var encounters: WMH_EncounterManager;
  protected var contract: WMH_ContractManager;

  protected var factory: WMH_HuntSeedFactory;
  protected var seed: int;

  private var start_time: GameTime;

  // stores the creatures that were killed during the current hunt, and that
  // should result in completed contracts the next time the player enters a
  // settlement.
  private var killed_creatures: array<WMH_BestiaryId>;

  public function init(master: WMH_Master): WMH_HuntManager {
    this.master = master;

    this.encounters = (new WMH_EncounterManager in this).init();
    this.contract = (new WMH_ContractManager in this).init();
    this.GotoState('Waiting');

    return this;
  }

  public function getSeed(): int {
    return this.seed;
  }

  public function onHuntStarted(storage: WMH_Storage) {
    var index: int = 0;

    this.factory = WMH_HuntSeedFactory(
      storage.getLevel(),
      index,
      WMH_getGameTimeMinutes()
    );

    this.seed = (
      this.factory.level.value
      * (this.factory.index + 1)
      + this.factory.timeoffset
    ) as int;

    WMH_setHuntSeedFact(this.seed);

    this.start_time = WMH_getGameTimeNow();
    this.killed_creatures.Clear();

    if (this.GetCurrentStateName() == 'Waiting') {
      this.GotoState('Running');
    }
  }

  public function onHuntFinished(
    bestiary: WMH_Bestiary,
    storage: WMH_Storage
  ) {
    if (this.GetCurrentStateName() == 'Running') {
      this.GotoState('Waiting');
    }

    this.contract.onHuntFinished(bestiary, storage, this.killed_creatures);
    this.encounters.onHuntFinished();
  }

  public function onCreatureKilled(bentry: WMH_BestiaryEntry) {
    this.killed_creatures.PushBack(bentry.id);
  }

  public function onSpawn(seed: int) {
    this.contract.onSpawn(seed);
  }

  public function onEncounterSpawned(encounter: WMH_Encounter) {
    this.encounters.onEncounterSpawned(encounter);
  }

  public function difficulty(): int {
    var seed: int = this.seed + HuntSeedOffset_difficulty!;

    var max: int = (this.factory.level.value + 2) as int;
    var min: int = Max((this.factory.level.value - 2) as int, 0);

    return RandNoiseF(
      seed,
      max as float,
      min as float
    ) as int;
  }

  protected function getSecondsSinceStart(): int {
    if (this.GetCurrentStateName() != 'Running') {
      return 0;
    }

    return WMH_getGameTimeSecondsSince(this.start_time);
  }
}

function WMH_setHuntSeedFact(seed: int) {
  FactsSet("WMH_hunt_seed", seed);
}

function WMH_getHuntSeedFact(): int {
  return FactsQueryLatestValue("WMH_hunt_seed");
}