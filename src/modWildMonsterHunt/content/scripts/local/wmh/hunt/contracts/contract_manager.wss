#define const ContractDurationMinutes = 60 * 5;

function WMH_getContractManager(): WMH_ContractManager {
  return thePlayer.wmh.hunt.contract;
}

/// Keeps track of the currently active contract targets the player has
statemachine class WMH_ContractManager {
  public var pending_contracts: array<WMH_PendingContract>;

  /// Hunt wide affixes applied to every creature that's spawned during it.
  public var hunt_affix_manager: WMH_AffixManager;
  /// Hunt wide spawn influences from all the pending contracts
  public var hunt_spawn_influences: array<WMH_ContractSpawnInfluence>;

  public function init(bestiary: WMH_Bestiary, storage: WMH_Storage): WMH_ContractManager {
    this.hunt_affix_manager = new WMH_AffixManager in this;
    this.onHuntFinished(bestiary, storage);
    this.GotoState('Waiting');

    return this;
  }

  public function onHuntStarted(bestiary: WMH_Bestiary) {
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onHuntStarted(bestiary);
    }

    this.refreshCachedHuntData();
  }

  public function onHuntFinished(
    bestiary: WMH_Bestiary,
    storage: WMH_Storage,
    optional killed_creatures: array<WMH_HuntKill>
  ) {
    var previous_level: WMH_Level = storage.general.level;
    var next_milestone: WMH_Level = WMH_Level(
      ((previous_level.value as int) / this.milestoneContractsInterval() + 1)
      * this.milestoneContractsInterval()
    );

    this.loadContractsFromStorage(bestiary, storage.contract);

    // side-effect: the storage is mutated from this
    this.finishCompletedContracts(
      killed_creatures,
      storage,
      next_milestone
    );

    var new_level: WMH_Level = storage.general.level;

    this.finishExpiredContracts(storage.contract, new_level);

    var milestones_to_generate: int = (new_level.value >= next_milestone.value) as int;

    var contracts_to_generate: int = 5
                                   - this.pending_contracts.Size()
                                   - milestones_to_generate;

    if (milestones_to_generate > 0) {
      this.generateNewPendingContracts(
        bestiary,
        storage.contract,
        next_milestone,
        1, // only generate one milestone at a time
        WMH_PendingContractType_MILESTONE
      );
    }

    if (contracts_to_generate > 0) {
      this.generateNewPendingContracts(
        bestiary,
        storage.contract,
        new_level,
        contracts_to_generate,
        WMH_PendingContractType_DEFAULT
      );
    }

    this.loadContractsFromStorage(bestiary, storage.contract);
    this.refreshCachedHuntData();
  }

  public function onContractReplaced(index: int, new_contract: WMH_Contract) {
    if (index < this.pending_contracts.Size()) {
      var pending: WMH_PendingContract = this.pending_contracts[index];
      
      if (pending) {
        if (pending.contract.type == WMH_PendingContractType_MILESTONE) {
          return;
        }

        this.pending_contracts[index] = (new WMH_PendingContract in this)
          .init(
            WMH_getBestiary(),
            new_contract,
            true
          );
      }
    }
  }

  public function onContractLevelChanged(index: int, change: int) {
    if (index < this.pending_contracts.Size()) {
      var pending: WMH_PendingContract = this.pending_contracts[index];
      
      if (pending) {
        if (pending.contract.type == WMH_PendingContractType_MILESTONE) {
          return;
        }

        var general: WMH_StorageGeneral = WMH_getStorageGeneral();
        var contract: WMH_Contract = pending.contract;
        contract.level.value = Clamp(
          FloorF(contract.level.value + change),
          0,
          FloorF(general.level.value)
        );

        this.pending_contracts[index] = (new WMH_PendingContract in this)
          .init(
            WMH_getBestiary(),
            contract,
            true
          );
      }
    }
  }

  public function onSpawn(bestiary: WMH_Bestiary, seed: int) {
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onSpawn(bestiary, seed);
    }

    // the order in the function calls is important, we want the spawnpoints to
    // be used for spawning creatures first then the ones that were skipped will
    // have a chance to spawn clues.
    for contract: WMH_PendingContract in this.pending_contracts {
      contract.onSpawn_clues(bestiary, seed);
    }
  }

  public function isTargetted(
    id: WMH_BestiaryId,
    optional contract_type: WMH_PendingContractType
  ): bool {
    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      // caller is targetting a specific type of contract
      if (
        contract_type != WMH_PendingContractType_DEFAULT
        && contract.getType() != contract_type
      ) {
        continue;
      }

      if (contract.isTargetted(id)) {
        return true;
      }
    }

    return false;
  }

  public function getTargettingContracts(
    out contracts: array<WMH_PendingContract>,
    id: WMH_BestiaryId,
    optional contract_type: WMH_PendingContractType
  ) {
    for contract: WMH_PendingContract in this.pending_contracts {
      // caller is targetting a specific type of contract
      if (
        contract_type != WMH_PendingContractType_DEFAULT
        && contract.getType() != contract_type
      ) {
        continue;
      }

      if (contract.isTargetted(id)) {
        contracts.PushBack(contract);
      }
    }
  }

  public function getTargetingContractsCount(id: WMH_BestiaryId): int {
    var count: int = 0;

    for contract: WMH_PendingContract in this.pending_contracts {
      count += contract.isTargetted(id) as int;
    }

    return count;
  }

  public function getPendingTargetsNameHtml(): array<string> {
    var output: array<string>;

    for pending: WMH_PendingContract in this.pending_contracts {
      output.PushBack(pending.toTargetLocNameHtml());
    }

    return output;
  }

  public function getPendingTargetsKill(): array<WMH_HuntKill> {
    var output: array<WMH_HuntKill>;

    for pending: WMH_PendingContract in this.pending_contracts {
      for target: WMH_ContractTarget in pending.targets {
        output.PushBack(WMH_HuntKill(
          target.bentry.id,
          WMH_EncounterTag_ContractRegular
        ));
      }
    }

    return output;
  }

  public function getHuntLevel(): WMH_Level {
    var output: WMH_Level;

    // get the highest level among the contracts
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.contract.level.value > output.value) {
        output = contract.contract.level;
      }
    }

    return output;
  }

  // returns how many WMH_Levels are needed before a new milestone contract is
  // generated.
  public function milestoneContractsInterval(): int {
    return 5;
  }

  public function toContractsDescriptionHtml(): string {
    var output: string;
    var br: string = "<br/>";

    var provider: WMH_RewardProvider = new WMH_RewardProvider in this;
    provider.startGroup("REWARDS").lockGroups(true);

    output += "<font size='24' color='#8a5551'>TARGETS:</font>" + br;
    for pending: WMH_PendingContract in this.pending_contracts {
      output += " - " + pending.toTargetLocNameHtml() + br;

      pending.getItemRewards(provider);
    }

    if (this.hunt_affix_manager.has_affix) {
      output += br + br + "<font size='24' color='#8a5551'>AFFIXES:</font> " + this.hunt_affix_manager.toLocString() + br;
    }

    if (this.hunt_spawn_influences.Size()) {
      output += br + br + "<font size='24' color='#8a5551'>INFLUENCES:</font>" + br;
      output += "<font size='18'>The presence of the target has an influence on the region's ecosystem, the chances to meet the following species during the hunt are altered:</font>";
      output += br;

      var bestiary: WMH_Bestiary = WMH_getBestiary();

      for influence: WMH_ContractSpawnInfluence in this.hunt_spawn_influences {
        var bentry: WMH_BestiaryEntry = bestiary.entries[influence.bestiary_id.value];
        var influence_perc: int = Abs(FloorF(influence.influence * 100));
        var sign: string = "<font color='#1c8139' size='22'>+";

        if (influence.influence < 0) {
          sign = "<font color='#cf222e' size='22'>-";
        }

        output += " - " + bentry.getLocName() + ": ";
        output += sign + influence_perc + "%</font>" + br;
      }
    }

    output += br + br + "<font size='24' color='#8a5551'>REWARDS:</font> " + provider.toHtml(thePlayer.GetInventory(), true) + br;

    return output;
  }

  private function onContractCompleted(
    provider: WMH_RewardProvider,
    pending: WMH_PendingContract,
    storage: WMH_Storage,
    maximum_level: WMH_Level
  ) {
    pending.onContractCompleted(provider);

    var smith_merchants: array<WMH_SmithMerchant> = WMH_getSmithMerchants();

    for smith: WMH_SmithMerchant in smith_merchants {
      smith.onContractCompleted();
    }

    storage.contract.completed_contracts_count += 1;

    // experience gain is locked until the milestone contract is completed.
    if (!this.hasPendingMilestoneContract()) {
      WMHINFO("onContractCompleted, old level = " +  storage.general.level.value);
      // the formula makes that any contract of the same level grants 100% of a
      // level as experience. Then as the general.level increases it will require
      // stronger and stronger contracts to level up.
      var gain: float = MinF(
        ((pending.contract.level.value + 1.0) as float)
        / ((storage.general.level.value + 1.0) as float),

        // the maximum of levels that we can get from a single contract:
        2
      );

      storage.general.level.value = MinF(
        maximum_level.value,
        storage.general.level.value + gain
      );

      WMHINFO("onContractCompleted, new level = " +  storage.general.level.value);
    }
  }

  private function finishCompletedContracts(
    out killed_creatures: array<WMH_HuntKill>,
    storage: WMH_Storage,
    maximum_level: WMH_Level
  ) {
    var completed_contracts: array<WMH_PendingContract>;
    var provider: WMH_RewardProvider = new WMH_RewardProvider in this;
    var completed_any: bool = false;

    // 1.0
    // first complete the milestone contracts to unlock the XP
    for contract: WMH_PendingContract in this.pending_contracts {
      var milestone: WMH_MilestoneContract = contract as WMH_MilestoneContract;

      if (milestone) {
        var completed: bool = milestone.canBeCompleted(killed_creatures, true);

        if (completed) {
          completed_contracts.PushBack(milestone);
        }
      }
    }

    for contract: WMH_PendingContract in completed_contracts {
      this.removePendingContract(storage.contract, contract);
      this.onContractCompleted(provider, contract, storage, maximum_level);
      completed_any = true;
    }
    completed_contracts.Clear();

    // 2.0
    // then complete the regular pending contracts
    for contract: WMH_PendingContract in this.pending_contracts {
      var completed: bool = contract.canBeCompleted(killed_creatures);

      if (completed) {
        completed_contracts.PushBack(contract);
      }
    }

    for contract: WMH_PendingContract in completed_contracts {
      this.removePendingContract(storage.contract, contract);
      this.onContractCompleted(provider, contract, storage, maximum_level);
      completed_any = true;
    }

    if (completed_any) {
      provider.transferItems(thePlayer.GetInventory());
      WMHPOPUP(provider.toHtml(thePlayer.GetInventory()));
    }
  }

  private function hasPendingMilestoneContract(): bool {
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.getType() == WMH_PendingContractType_MILESTONE) {
        return true;
      }
    }

    return false;
  }

  private function finishExpiredContracts(
    storage_contract: WMH_StorageContract,
    level: WMH_Level
  ) {
    var expired_contracts: array<WMH_PendingContract>;

    var contract: WMH_PendingContract;
    for contract: WMH_PendingContract in this.pending_contracts {
      if (contract.isContractExpired()) {
        expired_contracts.PushBack(contract);
      }
    }

    for contract: WMH_PendingContract in expired_contracts {
      this.removePendingContract(storage_contract, contract);
    }
  }

  private function removePendingContract(
    storage_contract: WMH_StorageContract,
    contract: WMH_PendingContract
  ) {
    this.pending_contracts.Remove(contract);
    storage_contract.pending_contracts.Remove(contract.contract);
  }

  private function generateNewPendingContracts(
    bestiary: WMH_Bestiary,
    storage_contract: WMH_StorageContract,
    level: WMH_Level,
    count: int,
    contract_type: WMH_PendingContractType
  ) {
    var now: int = WMH_getGameTimeMinutes();
    
    var i: int;
    for (i = count; i > 0; i -= 1) {
      storage_contract.pending_contracts.PushBack(
        WMH_Contract(
          level,
          now,
          i,
          contract_type
        )
      );
    }
  }

  private function loadContractsFromStorage(
    bestiary: WMH_Bestiary,
    storage_contract: WMH_StorageContract
  ) {
    this.pending_contracts.Clear();

    for contract: WMH_Contract in storage_contract.pending_contracts {
      WMHINFO("loadContractsFromStorage, loading contract, type = " + contract.type);


      if (contract.type == WMH_PendingContractType_MILESTONE) {
        this.pending_contracts.PushBack(
          (new WMH_MilestoneContract in this)
            .initMilestoneContract(bestiary, contract)
        );
      }
      else {
        this.pending_contracts.PushBack(
          (new WMH_PendingContract in this)
            .init(bestiary, contract, true)
        );
      }
    }
  }

  private function refreshCachedHuntData() {
    // reset the affixes then merge the ones from all contracts into this
    // single manager:
    this.hunt_affix_manager = new WMH_AffixManager in this;
    this.hunt_spawn_influences.Clear();

    for contract: WMH_PendingContract in this.pending_contracts {
      this.hunt_affix_manager.absorb(contract.affix_manager);

      for influence: WMH_ContractSpawnInfluence in contract.spawn_influences {
        this.addHuntSpawnInfluence(influence);
      }
    }
  }

  private function addHuntSpawnInfluence(influence: WMH_ContractSpawnInfluence) {
    var i: int;

    
    for (i = 0; i < this.hunt_spawn_influences.Size(); i += 1) {
      if (influence.bestiary_id == this.hunt_spawn_influences[i].bestiary_id) {
        this.hunt_spawn_influences[i].influence += influence.influence;

        return;
      }
    }

    this.hunt_spawn_influences.PushBack(influence);
  }
}