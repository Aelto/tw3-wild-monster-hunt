struct WMH_BestiaryId {
  var value: int;
}

class WMH_BestiaryEntry {
  public var id: WMH_BestiaryId;

  protected var difficulty_scaling: WMH_DifficultyScaling;
  protected var templates: array<WMH_EnemyTemplate>;

  protected var biome_tag_bypass: name;

  public var strength: float;

  public function init(id: WMH_BestiaryId) {
    this.id = id;
  }

  public function getLocName(): string {
    return "Unknown";
  }

  public function canBeTarget(level: WMH_Level): bool {
    // in the early levels we only target the small monsters
    if (level.value < NoonWraithStrength! && this.strength < NoonWraithStrength!) {
      return true;
    }

    return this.strength >= level.value - 1 && this.strength <= level.value + 1;
  }

  // This can also be used to determine if an entry can spawn. If the ratio is
  // greater than 0 than it can potentially spawn.
  public function canSpawn(
    biome: WMH_BiomeTags,
    day_hour: float,
    weather: WMH_WeatherType,
    optional biome_tags_bypass: array<name>
  ): bool {
    if (
      IsNameValid(this.biome_tag_bypass)
      && biome_tags_bypass.Contains(this.biome_tag_bypass)
    ) {
      return true;
    }

    return this.getSpawnRatio(
      biome,
      weather,
      day_hour
    ) > 0;
  }

  public function getSpawnRatio(
    tags: WMH_BiomeTags,
    weather: WMH_WeatherType,
    day_hour: float
  ): float {
    return 1.0;
  }

  public function buildSpawnList(seed: int): array<string> {
    var spawn_count: int = RandNoiseF(
      seed,
      // todo: use other difficulties than medium
      this.difficulty_scaling.maximum_count_medium,
      this.difficulty_scaling.minimum_count_medium
    ) as int;

    // 1.
    // make a copy of the templates from this entry
    var active_templates: array<WMH_EnemyTemplate>;
    var i: int;

    for (i = 0; i < this.templates.Size(); i += 1) {
      active_templates.PushBack(this.templates[i]);
    }

    var output_templates: array<string>;

    while (true) {
      var active_templates_size: int = active_templates.Size();
      if (active_templates_size <= 0) {
        break;
      }

      if (output_templates.Size() >= spawn_count) {
        break;
      }

      var index: int = RandNoiseF(
        seed + spawn_count,
        active_templates_size
      ) as int;

      var selected_template: WMH_EnemyTemplate = active_templates[index];

      WMHINFO("buildSpawnList() - adding " + selected_template.template);

      output_templates.PushBack(selected_template.template);
      active_templates[index].max -= 1;

      // reached the limit of this template per group
      if (active_templates[index].max <= 0) {
        // remove it from the available templates
        active_templates.EraseFast(index);
      }
    }

    return output_templates;
  }

  // Entries can override this function to tweak the newly spawned entities
  public function onEntitySpawned(entity: CEntity) {
    this.addCustomLoot((entity as CActor).GetInventory());
    (entity as CNewNPC).SetLevel(thePlayer.GetLevel());
  }

  // Entries can override this function to add custom loot to their entities
  public function addCustomLoot(inventory: CInventoryComponent) {
    // todo!("inventory.AddMoney(1)")
  }
}

struct WMH_EnemyTemplate {
  var template : string;

  // the maximum amount of this template per group
  var max      : int;

  var bestiary_entry: string;
}

struct WMH_DifficultyScaling {
  var minimum_count_easy: int;
  var maximum_count_easy: int;
  
  var minimum_count_medium: int;
  var maximum_count_medium: int;
  
  var minimum_count_hard: int;
  var maximum_count_hard: int;
}