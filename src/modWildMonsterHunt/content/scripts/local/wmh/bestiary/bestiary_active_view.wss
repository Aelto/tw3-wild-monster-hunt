// Acts as a dynamic view (like in databases) of the list of active bestiary
// entries. A bestiary entry can be considered active or inactive depending on
// the time of day, or the surrounding biomes for example.
//
// As the player moves around the maps the view is adjusted to match the new
// data.
class WMH_BestiaryActiveView {
  private var entries: array<WMH_BestiaryEntry>;

  // caches the spawn ratios for each entry as it may vary based on the
  // weather, time, and contracts.
  private var entries_ratios: array<float>;

  private var refresh_ticker: WMH_Ticker;

  public function init(): WMH_BestiaryActiveView {
    this.refresh_ticker = (new WMH_Ticker in this).init(60); // seconds

    return this;
  }

  public function maybeRefresh(
    entries: array<WMH_BestiaryEntry>,
    biome_manager: WMH_BiomeManager,
    contract: WMH_ContractManager
  ) {
    if (!this.refresh_ticker.validate()) {
      return;
    }

    this.updateView(entries, biome_manager, contract);
  }

  private function updateView(
    entries: array<WMH_BestiaryEntry>,
    biome_manager: WMH_BiomeManager,
    contract: WMH_ContractManager,
  ) {
    var weather: WMH_WeatherType = biome_manager.getWeatherType();
    var biome: WMH_BiomeTags = biome_manager.getGlobalBiome();
    var day_hour: int = biome_manager.getDayHour();
    var current: WMH_BestiaryEntry;

    this.entries.Clear();
    this.entries_ratios.Clear();

    // build a list with just the entries that we allow to spawn
    for current: WMH_BestiaryEntry in entries {
      // this is where additional filtering can be done, for example based on
      // the player's progression through the game or if the species are in
      // the player's bestiary.

      // targetted entries have more chances to spawn
      var is_targetted_f: float = contract.isTargetted(current.id) as float;
      var ratio: float = current.getCurrentRangeScaling(day_hour);

      if (ratio > 0) {
        this.entries.PushBack(current);
        this.entries_ratios.PushBack(ratio * (5.0 * is_targetted_f));
      }

    }
  }

  public function getRandomEntry(
    biome_manager: WMH_BiomeManager,
    biome_tags: WMH_BiomeTags,
    biome_tags_bypass: array<name>,
    seed: int
  ): WMH_BestiaryEntry {
    var weather: WMH_WeatherType = biome_manager.getWeatherType();
    var day_hour: int = biome_manager.getDayHour();
    var global_biome: WMH_BiomeTags = biome_manager.getGlobalBiome();

    var roller: WMH_RatiosRoller = new WMH_RatiosRoller in this;

    // 1.
    // start by building a list of the entries that could spawn from the
    // provided biome tags.
    var i: int;
    for (i = 0; i < this.entries.Size(); i += 1) {
      var current: WMH_BestiaryEntry = this.entries[i];

      var can_spawn_f: float = current.canSpawn(
        biome_tags,
        day_hour,
        weather,
        global_biome,
        biome_tags_bypass
      ) as float;

      // the ratios are pre-computed, so depending on whether the entry can
      // spawn for the more precise conditions now we simply set the
      // pre-computed ratio to 0 if it cannot.
      roller.addRatio(this.entries_ratios[i] * can_spawn_f);
    }

    var index: int = roller.roll(seed);

    if (index < 0) {
      return NULL;
    }

    return this.entries[index];
  }
}